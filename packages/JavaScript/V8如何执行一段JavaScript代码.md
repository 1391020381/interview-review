# 编译器 和 解释器
* 编译型语言在程序执行之前,需要经过编译器的编译过程,并且编译之后会直接保存机器码能读懂的二进制文件,这样每次运行程序时,都可以直接运行该二进制文件,而不需要再次进行重新编译了。
* 解释型语言编写的程序,在每次运行时都需要通过解释器堆程序进行动态解释和执行。

* 编译型语言的编译过程中,编译器首先会依次对源代码进行词法分析 语法分析 生成抽象语法树 AST 然后 优化代码 最后再生成处理器能够理解的机器码。如果编译成功 将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误 那么编译器就会抛出异常,最后的二进制文件也不会生成成功。

* 在解释型语言的解释过程中,同样解释器也会对源代码进行词法分析 语法分析 并生成抽象语法树 ast 不过它会再基于语法树生成字节码 最后再根据字节码来执行程序 输出结果。


* 通常 如果有一段第一次执行的字节码 解释器 Igition会逐条解释执行。到了这里,相信你已经发现了,解释器Ignition除了负责生成字节码之外,它还有另外一个作用,就是解释执行字节码。
* 在Ignition执行字节码的过程中,如果发现有热点代码(HotSpot),比如一段代码被重复执行多次,这种就称为  热点代码, 那么后台的编译器 TurboFan就会把该热点的字节码编译为高效的机器码,然后当再次执行这段被优化的代码时,只需要执行编译后的机器码就可以了,这样就大大提升了代码的执行效率。
* 其实字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为即时编译（JIT）。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。
# JavaScript的性能优化
* 提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；
* 避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；
* 减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。

# V8 执行时间越久，执行效率越高
* 执行时间越长，执行效率越高。是因为更多的代码成为热点代码之后，转为了机器码来执行。