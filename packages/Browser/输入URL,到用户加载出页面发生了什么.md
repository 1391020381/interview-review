* 浏览器进程
* 渲染进程
* GPU
* 网络进程
* 插件进程


* [HTTP 请求流程示意图](https://static001.geekbang.org/resource/image/1b/6c/1b49976aca2c700883d48d927f48986c.png?wh=1142*423)

* 响应行返回的状态码是 301，状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。

* DNS解析的过程其实并没有建立一个持久的连接。这是因为DNS使用的是无连接的UDP协议，而不是像HTTP或HTTPS那样使用的是基于连接的TCP协议

* 结合老师的讲义，自己总结了下，不考虑用户输入搜索关键字的情况：
1. 用户输入url并回车
2. 浏览器进程检查url，组装协议，构成完整的url
3. 浏览器进程通过进程间通信（IPC）把url请求发送给网络进程
4. 网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程
5. 如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：
    5.1 进行DNS解析，获取服务器ip地址，端口（端口是通过dns解析获取的吗？这里有个疑问）
    5.2 利用ip地址和服务器建立tcp连接
    5.3 构建请求头信息
    5.4 发送请求头信息
    5.5 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容
6. 网络进程解析响应流程；
    6.1 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步
            （301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。
    6.2 200响应处理：
            检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行
            后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。
7. 准备渲染进程
    7.1 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程
8. 传输数据、更新状态
    8.1 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
    8.2 渲染进程接收完数据后，向浏览器发送“确认提交”
    8.3 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面。

9. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
10. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
11. 创建布局树，并计算元素的布局信息。
12. 对布局树进行分层，并生成分层树。
13. 为每个图层生成绘制列表，并将其提交到合成线程。
14. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
15. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
16. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。
