# JavaScript内存机制
## 数据存储方式
1. JavaScript数据类型
    - 弱类型 动态语言
    - 原始类型 引用类型
2. 数据存储位置
    - 原始类型存放在栈中
    - 引用类型存放在堆中
3. 栈空间和堆空间
    - 栈空间   存储执行上下文 存放原始类型数据
    - 堆空间   存放引用类型数据  大空间 存放大数据 
4.  闭包的内存模型   闭包的产生的过程  内部函数引用外部变量 外部变量保存在堆中
5. 对象拷贝  完整拷贝  两个对象互不影响

* 代码空间 栈空间 堆空间
* 栈空间就是我们之前反复提及的调用栈 时用来储存执行上下文的。
* JavaScript引擎需要用栈累维护程序执行期间上下文的状态,如果栈空间大了话，所有的数据都存放在栈空间里面,那么会影响到上下文切换的效率,进而又影响到整个程序的执行效率。

* 通常情况下,栈空间都不会设置太大,主要用来存放一些原始类型的小数据。
* 堆空间很大,能存放很多大的数据。 缺点是分配和回收内存都会占用一定时间。

* 原始类型的赋值会完整复制变量。
* 引用类型的赋值是复制引用地址。




```
// 闭包回收
   let myClosure = (function() {
      let privateVar = "I am private";
      return function() {
         return privateVar;
      }
   })();
   
   // 在这里使用 myClosure
   myClosure = null; // 当不再使用闭包时，将其设置为null

   for(let i = 0; i < 10; i++) {
      setTimeout(function() {
         console.log(i);
      }, 1000);
   }
* 这里的关键原因是 let 关键字的行为和 var 不同。
在循环内部，每次迭代 let 都会创建一个新的块级作用域，这就 means，每次迭代都有一个新的 i 实例。因此，当 setTimeout 回调函数在稍后执行时，它引用的是和当时迭代相关的 i 的特定实例，它的值被保存和封闭在 setTimeout 的函数作用域内，这也就是为什么你看到的是0到9，而不是10个10。

```

# 垃圾回收
## 垃圾回收的自动回收
1. JavaScript中数据存储方式
    - 原始数据类型存储在栈空间
    - 引用类型数据存储在堆空间
2. 垃圾数据的回收策略   
    - 手动回收  C / C++ 的手动回收
    - 自动回收  JavaScript Java
## JavaScript中的垃圾数据回收
1. 调用栈中数据回收  
    - 执行流程分析 ESP指针的作用
2. 堆中数据回收
    - 代际假说和分代收集
        - 大部分对象在内存中存在的时间很短 简单来说 就是很多对象一经分配内存,很快就变得不可访问
        - 不死的对象 会活的更久
        - 新生代 1 ～ 8 M 容量
        - 老生代
        - 不论什么类型的垃圾回收器 它们都有一套共同的执行流程
        - 第一步 标记空间中活动对象 非活动对象  所谓活动对象就是还在使用的对象 非活动对象就是可以进行垃圾回收的对象
        - 第二部 回收非活动对象所占据的内存。 其实就是在所有标记完成之后,统一清理内存中所有被标记为可回收的对象
        - 第三部 内存整理 一般来说 频繁回收对象后,内存中就会存在大量不连续空间,我们把这些不连续的内存空间称为 内存碎片。
    - 垃圾回收器的工作流程  
        - 副垃圾回收器   Scavenge算法  对象晋升策略  
        -   对象区域 空闲区域  新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作
        - 垃圾回收 前面说三步。 把存活的对象 复制到空闲区域，并有序排列。 且角色反转
        - 也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。
        - 主垃圾回收器   标记清除算法    标记 整理算法
        - 全停顿  增量标记算法  
        - JavaScript是运行在主线程之上的,一旦执行垃圾回收算法,都需要将正在执行的js脚本停下来,待垃圾回收完毕再恢复脚本执行。 全停顿
        - 为了降低老生代的垃圾回收造成的卡顿 V8将标记分为一个个子标记过程,同时让垃圾回收标记和JS逻辑交替进行,直到标记阶段完成。

# 判断JavaScript中内存泄漏的方法
# 工作过程中避免内存泄漏的方法      


* ![及时编译技术](https://static001.geekbang.org/resource/image/66/8a/662413313149f66fe0880113cb6ab98a.png?wh=766*912)


* js优化
    1. 提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；
    2. 避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；
    3. 减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。