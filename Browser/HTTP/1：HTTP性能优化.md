* HTTP是浏览器中最重要且使用最多的协议,是浏览器和服务器之间的通讯语言。


# 超文本传输协议 HTTP/0.9
* 主要用于学术交流 需求很简单 用来在网络之间传递HTML超文本的内容,所以被称为 超文本传输协议。
* 采用了基于请求响应的模式,从客户端发出请求,服务端返回数据。
## HTTP/0.9一个完整的请求流程
1. DNS 域名 解析称IP  因为 HTTP都是基于TCP协议的,所以客户端先要根据IP地址 端口 和服务器建立TCP连接,而建立连接的过程就是TCP协议三次握手的过程。
2. 建立好连接之后,会发送一个GET请求行的信息,如GET /index.html 用来获取index.html.
3. 服务端接受信息之后,读取对应的HTML文件,并将数据以ASCII字符串返回给客户端。
4. HTML 文档传输完成后，断开连接。

## HTTP/1.0
* 支持多种类型的文件下载是HTTP/1.0的一个核心诉求, 文件格式不仅仅是ASCII编码。
* HTTP/1.0引入请求头和响应头 它们都是以 Key - Value形式保存的,在http发送请求时,会带上请求头信息。服务器返回数据时,会先返回响应头信息。
* 状态码
* Cache机制
* 用户代理 

## HTTP/1.1 
* keep-alive  默认开启 目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。
* 在一个TCP链接上可以传输多个http请求,只要浏览器或者服务器没有明确断开连接,那么tcp链接会一直保持。
* 持久连接虽然能减少tcp的建立和断开次数,但是它需呀等待前面的请求返回之后,才能进行下一次请求。
* 如果tcp通道中的某个请求因为某些原因没有及时返回,那么就会阻塞后面的所有请求,这就是著名的  队头阻塞 问题。
* 提供虚拟主机的支持 HTTP
* 举例来说，比如你有一个Web服务器，它的IP地址是192.0.2.1。在这个服务器上，你可能托管了两个不同的网站，它们的URL分别是www.example1.com和www.example2.com。当一个客户端想要访问www.example1.com的时候，它会发出如下的HTTP请求：
```
GET / HTTP/1.1
Host: www.example1.com


GET / HTTP/1.1
Host: www.example2.com



   server {
     server_name www.example1.com;
     # ...
   }
   
   server {
     server_name www.example2.com;
     # ...
   }

```
* 对动态生成的内容提供了完美支持  Chunk transfer机制  服务器会将数据分割成若干个任意大小的数据块,每个数据块发送时会附上数据块的长度,最后使用一个零长度的块作为发送数据完成的标志。

* Cookie 安全机制

# HTTP/2.0

##  http/1.1问题
1. tcp 慢启动  tcp连接建立之后,进入了发送数据的状态，刚开始tcp协议会采用一个非常慢的速度发送数据,然后慢慢加快发送数据的速度,直到发送数据的速度达到一个理想的状态。这个过程称为 慢启动。
    - 慢启动时tcp 减少网络拥塞的一种策略,我们无法改变的。
    - html css js文件 通常这些文件在tcp连接建立好之后就要发起请求的,但这个过程时慢启动,所以耗费时间比正常的时间要多很多,推迟了首次渲染页面的时长了。
2. 同时开启多条tcp连接 那么这些连接会竞争固定的带宽。
    - 不同tcp连接下载资源不同, 多条tcp连接无法协调优先下载，就影响了关键资源的下载速度。
3. http/1.1 队头阻塞的问题。
    - http/1.1持久连接 虽然公用一个tcp管道，但是在一个管道中同一时刻只能处理一个请求,在当前的请求没有结束之前,其他的请求只能处于阻塞状态。 这就意味我们不能随意在一个管道里发送请求和接受内容。  

## HTTP/2.0的多路复用
* 慢启动和tcp 连接之间相互竞争带宽是由于tcp本身机制导致
* 队头阻塞是http/1.1机制导致的。


* http/2.0的思路 就是一个域名只使用一个tcp长连接来传输数据,这样整个页面资源的下载过程只需要一次慢启动,同时避免多个tcp连接竞争带宽带来的问题。

![HTTP/2的多路复用](https://static001.geekbang.org/resource/image/0a/00/0a990f86ad9c19fd7d7620b2ef7ee900.jpg?wh=4526*1786)


* 通过引入二进制分帧层，就实现了 HTTP 的多路复用技术。
* 数据经过 二进制分帧层处理之后,会被转换为 一个个带有请求ID编号 stream id 的帧，通过栈协议将这写帧发送给服务器。 服务器 将相同 id合并为一条完整的请求信息。


* 可以设置请求的优先级
* 服务端推送
* 头部压缩

* HTTP/1.1中，头部与实际的数据内容都是作为纯文本传输的，这确实使得这个协议比较容易进行读取与理解。但同时，这种方式也增加了数据的传输量，并且可能产生冗余

* 使用HPACK规范进行二进制编码，并实现压缩。
* HPACK中定义了一套索引表（包括静态索引表和动态索引表），原本的头部字段会被编码成索引的方式进行传输，从而大大减少了头部信息的冗余以及传输的数据量。比如，对于频繁出现的头部字段，如"User-Agent"，"Accept-Encoding"等，只需要传输它们在索引表中的索引值即可。

# HTTP/3.0

* HTTP/2 在 2018 年就开始得到了大规模的应用


* 在TCP传输过程中,由于单个数据包的丢失而造成的阻塞称为 TCP上的队头阻塞。


* 我们知道在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。


* 把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT

* HTTP/3 中的 QUIC 协议集合了以下几点功能。
    - 实现类似tcp的流量控制 传输可靠性的功能
    - TLS加密
    - 多路复用
    - 快速握手